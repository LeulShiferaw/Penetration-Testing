1. Finding offset
	- The best way to do this is to overflow with a non-repeating sequence of characters and use the ascii value that is overflown at that point to determine the offset.

	- We can use `ERC –pattern c 5000` in x64dbg. Make sure to look at log (Alt + L).

	- The 5000 above is an upperbound to the offset of EIP. We can just overflow 1000, 2000, 3000, .. until the program crashes with EIP being the value that is overflown.

	- In order to control EIP and find the exact offset; we can overflow it with non-repeating patterns as stated above.

	- Run `ERC –pattern o <ASCII value of EIP>` to get the offset exactly.

2. Identifying bad characters
	- First generate all characters and overflow after eip

	- Then check where the overflowed data from stack stops being the same as the original input

	- Example:

		1. `ERC –bytearray` – to generate the input data to overflow. Get the code under C#.

		2. Run `ERC –compare <STACK VALUE> C:\Users\htb-student\Desktop\ByteArray.bin

		3. See where the values from memory and stack match and where it stops being the same. The barrier between the two is a bad character

		4. Rinse and repeat but this time with `ERC –bytearray -bytes <bad character hexadecimal>` until you have found all bad characters
		
3. Identifying Return Code
	- Find instructions that jump to esp.

	- There are three way to do this: one is find instructions that contain “jmp esp”, second is “push esp; ret”, and third is change the eip to the esp.

	- To find “jmp esp” in go to symbols, click the executable to search in, press Ctrl + F and search for “jmp esp”. This should generate a set of memory locations that contain that instruction.

	- For “push esp; ret”, since it is two instructions we need to search for the hexadecimal instead.

	- We can press Ctrl+B and enter the assembly code. For “Push esp; ret” which is 54C3
	
4. Final exploit
	- Now we have all the parts. We can have the offset, bad characters, and return code. We just need to generate the shell code, put it in the stack and execute it.

	- To generate the shellcode for windows we can use this command: 
		`msfvenom -p ‘windows/exec’ CMD=’cmd.exe’ -f ‘python’ -b ‘\x00’`

	- Don’t forget to remove the bad characters with -b option.

	- This command will generate the cmd.exe file. If we are running in admin mode it will have root privileges.

	- Final payload should be: payload = buffer + eip + nop + buf

	- buffer is b”A” * offset (4112 for this case), eip is the return code we found earlier, nop is a series of ‘\x90’ instructions that do nothing, and buf is the shellcode.